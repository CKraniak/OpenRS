Core modules:
- Dispatcher (event system core)
  - GameEvent
    - BooleanCombinationTree
    - BooleanCombinationTreeGenerator
  - GameEventHandler
- GlFunctionFinder (like a custom GLEW)
- GlCore
- CesCore
  - Entity
  - Component
  - System

An entity has components, which may or may not have systems that depend on them.

So there will be a top-level entity or entity-list? No.

LocalSystem vs. GlobalSystem types? No.

Data is owned by Components, which are used by systems, which essentially
iterate over lists of entitys with agreeable component types.

The main loop will invoke systems, which look up the needed entitys and call
other systems as needed. A system may be active or inactive, depending on
whether the main loop should default to calling it, and activity may depend on
the game's "state". So in state "getinfo", the InfoDisplay system is active.

Game loop pseudocode:
- Call state-active systems in the order defined by the state
  - Main thing changed by the state is the input-handling and the rendering
- State switches are usually decided by certain inputs, but may be automatic

States:
- init
  - ?
- menu
  - main_menu
    - ACT: getinput
      - active inputs are arrow keys, enter, escape, backspace
    - ACT: render
  - pause_menu
    - ACT: getinput
      - active input is esc
    - ACT: render
  - help_menu
    - ACT: getinput
      - active input not determined yet
    - ACT: render
  - options_menu_frommain
    - ACT: getinput
      - active input not determined yet
    - ACT: render
  - options_menu_fromgame
    - ACT: getinput
      - active input not determined yet
    - ACT: render
- game
  - init
  - exit
  - base
    - ACT: getinput
      - active inputs are numpad keys, F1, esc, mouse, and state_change keys
  - get_info
  - interact
  - build
  - worldmap
  - districtmap

******************************************

Entity types needed:
- Player
- Monster
- MedKit
- Door
- Shelf
- Weapon

Components needed for each:
- Player:
  - Health
  - MaxHealth
  - AttackPower
  - Position
  - EquippedItem
  - Inventory
  - Sprite
  - Alliance
  - InfoText
  - RenderType
- Monster:
  - Health
  - MaxHealth
  - AttackPower
  - Position
  - AI
  - EquippedItem
  - Sprite
  - Alliance
  - InfoText
  - RenderType
- MedKit
  - Value
  - Position
  - Sprite
  - InfoText
  - RenderType
- Door
  - State
  - Position
  - Sprite
  - RenderType
- Weapon
  - Type (ranged vs. melee)
  - Power
  - Position
  - Sprite
  - InfoText
  - RenderType

RenderType:
  - menu
  - gamegrid
  - none (not needed, nonexistence of RenderType component implies "none")
  - gameconsole
  - inventorygrid
  - gamemap

Systems:
  - Combat
  - Render
  - Collision
    - Calls combat system on collision of entitys with enemy alliances
    - Calls interaction system on collision of entitys with allied alliance
  - Movement
    -
  - Input
    - Calls movement system on movement input (numpad keys, mostly)
    -
  - InfoDisplay
  - State (?)
    - Kind of modifies the behavior of most other systems:
      - Input will move menus around, but does a bit more in an in-game state
      - There is no menu combat
      - There is no menu collision
      - If in a "getinfo" state, most inputs get supressed, except mouse

************************************************************

Menu Entity Types:
- BasicSelection
- Radio
- Checkbox
- Slider
- NumericInput


- BasicSelection
  - in_menu
  - text
  - text_color
- Radio
  - in_menu
- RadioItem
  - in_radio
  - text
etc.

Menu audio:
  - audio = soundofsilence

Entity: mainmenu:
  - menu_order_resolution_rule:
    - Continue Game
    - New Game
    - Load Game
    - unlisted_new_by_placenum_then_alphabetical
    - Options
    - About
    - Exit
  - background_color = 0x000000ff (rgba)
  - selected = 0
  - menu_name = "main"
  - check_continuegame_on_activate = true

Buttons:
- type: BasicSelection
  - text = "New Game"
  - text_color = 0xeeeeeeff (rgba)
  - in_menu = "main"
  - on_selected = "new_game"
- type: BasicSelection
  - text = "Load Game"
  - text_color = 0xeeeeeeff (rgba)
  - in_menu = "main"
  - on_selected = "load_game"
etc.

ButtonOrder:
  - list of Button entitys

***************************************************************

Minimalist start:
- Set init_mainmenu as the new state
- Jump into the update loop
- Update loop sees new state, calls state-init with previous state info intact
  - init_mainmenu loads / activates mainmenu entity
  - init_mainmenu loads all entitys with in_menu = "main"
  - init_mainmenu sets new state to menu
- State switch event is generated, currently nobody cares except state tracker
- update called, sees state "menu":
  - grabs main menu background color and text
  - updates menu render structure
- Renderer renders
- Loop renderer (with no state updates) while waiting for input
  - Takes care of window movement and resizes, minimization, etc.
- Input of either enter or arrow key
  - If enter, get selected's on_selected and looks up associated switching rule
  - If arrow, find new selected
  - need_update is set if need be

*****************************************************************

Need:
- Generic menu updating function
- Generic menu input handling function

****************************************************************

on_selected("new_game"):
- deactivate_current_menu
- activate_menu = "newgame"

on_selected("game_init"):
- deactivate_current_menu (if prev. state was a menu)
- activate_game = game_properties

Game:
- turn
- district_list
- width
- height

District:
- terrain_list
- entity_list
- environment
- width
- height

*******************************************************************

Begin game:
- Create game entity, populate
  - Creates districts, populates each, given environment, width, and height
    - Populate terrain_list using whichever generator
    - Populate entity_list using whatever generator
- Input then goes to:
  - movement system (numpad keys)
  - state changing (currently none)
- Movement system, given input, default method will be:
  - get the current movement_target (retrieved from district)
    - has components "location", "move_type=numpad"
  - apply input to movement_target if no collision, otherwise resolve collision
  - if all movement_targets processed, send "increment_turn" event
- AI system
  - have list of objects with "AI" component
  - for alpha 1, only a simple_enemy_1 AI will be defined
  - call the defined AI script / function
    - simple_enemy_1 will find the shortest path to an object of
        player_alleigance, and return request to move toward / attack player
- Combat system
  - Given an attacker entity (has "AttackPower", optionally an attack modifier)
  - Given a defender entity (has "Health", "Armor", any modifiers of the two)
  - Determines damage to apply to defender using whatever formula / RNG
  - Applies damage
  - Sends message to defender, if applicable
    - either run on_attacked or on_killed or somesuch
    - default on_attacked is nothing
    - default on_killed removes entity from district's entity_list
